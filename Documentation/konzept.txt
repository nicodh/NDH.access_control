Action method access control

class access control
	read
	write

conditional access rule:
	read:
		conditionProperty:
		conditionValue:
			denyValue:
			grantValue:

	read:
		conditionProperty:
		conditionValue:
			denyValue:
			grantValue:

property access rule
	read,
	write,
	readOwn,
	writeOwn,


accessDecisionManager

Role => Rules => RuleProcessor

RuleProcessor

Backend->supports(ObjectAccessRule)
Backend->supports(ObjectPropertyAccessRule)
Backend->supports(ConditionalObjectAccessRule)
Backend->supports(ConditionalObjectPropertyAccessRule)

Role		:	object	:read/write:	ACCESS

context: FE
	anonymous:
		fe_users:
			read:GRANT
			write:DENY

	intranet:
		fe_users:
			read:
				object: GRANT_ON_CONDITIONS
					conditions:
						conditionProperty: deleted
							conditionalValue:
								deny: 1
								grant: 0
						conditionProperty: hidden
							conditionalValue:
								deny: 1
								grant: 0

                allowed_exclude_fields:
                   	properties:	privatePhone, privateMail
						conditionProperty: vip
							conditionValue:
								deny: 1
								grant: 0


			write:
				allowed_exclude_fields:
					properties: password, birthdate, email, phone
						conditionProperty: fcruser_id
							conditionValue:
								grant: self->uid

						conditionProperty: pid
							conditionValue:
								grant: 244


enableFields by Role (Rule?)


Probleme:

1. Konflikt unique RollenIdentifier vs. persistence.uid
2. Konfiguration vs. Datenbank (TCA)
3. Verknüpfung von Datensätzen mit Rollen (RollenHierarchie)
4. Ableiten der Klassennamen von Tabellennamen nicht möglich => camelcase namen werden zu lowercase umgewandelt (recordType wg. SingleTable inheritance)
5. PropertyMapper kann nicht verwendet werden, da Argumente beliebige Namen haben können (?)

PointCut Expression for Controller actions:
@Flow\Pointcut("method(.*Controller->.*Action())")

implemented

Privilegien werden als serialisierter Array gespeichert (müssen nur einmal geladen und gemerged werden)??